%{
#include <iostream>
#include <stdio.h>
#include <stdarg.h>
#include <string>

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; };
%}

%union {
    int val;
};

%start program

%token <val> INTEGER
%token <val> VAR
%token <val> NUM


%token <val> PRINT IF THEN GOTO INPUT LET GOSUB RETURN CLEAR LIST RUN END
%token <val> STRING CR COMMA RELOP
%token LPAREN RPAREN
%token PLUS MIN MUL DIV

%type  <val> line statement expression term factor var-list expr-list

/* Order of directives will determine the precedence. */
%left PLUS MIN    /* left means left-associativity. */
%left DIV MUL


%%

program : line                          { std::cout << $1 << std::endl; }
        ;

line : INTEGER statement CR             { std::cout << $1 << $2 << std::endl; }           
     | statement CR                     { std::cout << $1 << std::endl; }
     | CR                               {}
     ;

statement : PRINT expr-list                                   { std::cout << $1 << $2 << std::endl; }
          | IF expression RELOP expression THEN statement     { std::cout << $1 << $2 << $3 << $4 << $5 << $6 << std::endl; }
          | GOTO expression                                   { std::cout << $1 << $2 << std::endl; }
          | INPUT var-list                                    { std::cout << $1 << $2 << std::endl; }
          | LET VAR '=' expression                            { std::cout << $1 << $2 << '=' << $4 << std::endl; }
          | GOSUB expression                                  { std::cout << $1 << $2 << std::endl; }
          | RETURN                                            { $$ = $1; }
          | CLEAR                                             { $$ = $1; }
          | LIST                                              { $$ = $1; }
          | RUN                                               { $$ = $1; }
          | END                                               { $$ = $1; }
          ;

expr-list : STRING                                            { $$ = $1; }
          | STRING ',' STRING                                 { std::cout << $1 << ',' << $3 << std::endl;}
          | STRING ',' expression                             { std::cout << $1 << ',' << $3 << std::endl;}
          | expression                                        { $$ = $1; }
          | expression ',' STRING                             { std::cout << $1 << ',' << $3 << std::endl;}
          | expression ',' expression                         { std::cout << $1 << ',' << $3 << std::endl;}
          ;


var-list : VAR COMMA VAR                { std::cout << $1 << ',' << $3 << std::endl; }
         | VAR                          { $$ = $1; }
         ;

expression : expression PLUS term       { $$ = $1 + $3; }
           | expression MIN term        { $$ = $1 - $3; }
           | term                       { $$ = $1; }
           ;

term : term MUL factor               { $$ = $1 * $3; }
     | term DIV factor               { $$ = $1 / $3; }
     | factor                        { $$ = $1; }
     ;

factor : VAR                            { $$ = $1; } 
       | INTEGER                        { $$ = $1; }
       | LPAREN expression RPAREN       { $$ = $2; }
       ;



%%

int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}